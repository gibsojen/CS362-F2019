        -:    0:Source:kingdom_cards.c
        -:    0:Graph:kingdom_cards.gcno
        -:    0:Data:kingdom_cards.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4://#include <math.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:
        -:    8:
        -:    9:
        -:   10:// remove an estate from the supply
        -:   11:// this is a helper function
function remEstateSupply called 2 returned 100% blocks executed 80%
        2:   12:int remEstateSupply (struct gameState *state) {
        2:   13:	state->supplyCount[estate]--;//Decrement Estates
        2:   14:        if (supplyCount(estate, state) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   15:        	isGameOver(state);
call    0 never executed
        -:   16:        }
        2:   17:	return 0;
        -:   18:}
        -:   19:
        -:   20:
        -:   21:
function baronCard called 4 returned 100% blocks executed 100%
        4:   22:int baronCard (int choice1, struct gameState *state, int currentPlayer) {
        -:   23:
        4:   24:	state->numBuys++;//Increase buys by 1!
        4:   25:        if (choice1 >= 0) { //Boolean true or going to discard an estate  //introduced bug from > to >=
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        3:   26:            int p = 0;//Iterator for hand!
        3:   27:            int card_not_discarded = 1;//Flag for discard set!
       15:   28:            while(card_not_discarded) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        9:   29:                if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
        2:   30:                    state->coins += 4;//Add 4 coins to the amount of coins
        2:   31:                    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        -:   32:                    //state->discardCount[currentPlayer]++;  //introduced bug by removing this line
       12:   33:                    for (; p < state->handCount[currentPlayer]; p++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       10:   34:                        state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   35:                    }
        2:   36:                    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        2:   37:                    state->handCount[currentPlayer]--;
        2:   38:                    card_not_discarded = 0;//Exit the loop
        -:   39:                }
        7:   40:                else if (p > state->handCount[currentPlayer]) {
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:   41:                    if(DEBUG) {
        -:   42:                        printf("No estate cards in your hand, invalid choice\n");
        -:   43:                        printf("Must gain an estate if there are any\n");
        -:   44:                    }
        1:   45:                    if (supplyCount(estate, state) > 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   46:                        gainCard(estate, state, 0, currentPlayer);
call    0 returned 100%
        -:   47:
        1:   48:			remEstateSupply(state);
call    0 returned 100%
        -:   49:                    }
        1:   50:                    card_not_discarded = 0;//Exit the loop
        -:   51:                }
        -:   52:
        -:   53:                else {
        6:   54:                    p++;//Next card
        -:   55:                }
        -:   56:            }
        -:   57:        }
        -:   58:
        -:   59:        else {
        1:   60:            if (supplyCount(estate, state) > 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   61:                gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 100%
        -:   62:
        1:   63:		remEstateSupply(state);
call    0 returned 100%
        -:   64:            }
        -:   65:        }
        -:   66:
        4:   67:	return 0;
        -:   68:}
        -:   69:
        -:   70:
        -:   71:
function minionCard called 4 returned 100% blocks executed 100%
        4:   72:int minionCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:   73:
        -:   74:	int i;
        -:   75:	int j;
        -:   76:        
        -:   77:	//+1 action
        4:   78:        state->numActions++;
        -:   79:
        -:   80:        //discard card from hand
        4:   81:        discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:   82:
        4:   83:	if (choice1)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   84:        {
        2:   85:            state->coins = state->coins + 4;  //introduced bug...changed from 2 coins to 4
        -:   86:        }
        2:   87:        else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:        {
        -:   89:            //discard hand
       12:   90:            while(numHandCards(state) > 0)
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        -:   91:            {
        8:   92:                discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:   93:            }
        -:   94:
        -:   95:            //draw 4
       10:   96:            for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   97:            {
        8:   98:                drawCard(currentPlayer, state);
call    0 returned 100%
        -:   99:            }
        -:  100:
        -:  101:            //other players discard hand and redraw if hand size > 4
        8:  102:            for (i = 0; i <= state->numPlayers; i++)  // introduced bug from < to <=
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  103:            {
        6:  104:                if (i != currentPlayer)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  105:                {
        4:  106:                    if ( state->handCount[i] > 4 )
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  107:                    {
        -:  108:                        //discard hand
       14:  109:                        while( state->handCount[i] > 0 )
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  110:                        {
       10:  111:                            discardCard(handPos, i, state, 0);
call    0 returned 100%
        -:  112:                        }
        -:  113:
        -:  114:                        //draw 4
       10:  115:                        for (j = 0; j < 4; j++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  116:                        {
        8:  117:                            drawCard(i, state);
call    0 returned 100%
        -:  118:                        }
        -:  119:                    }
        -:  120:                }
        -:  121:            }
        -:  122:
        -:  123:        }
        4:  124:        return 0;
        -:  125:
        -:  126:
        -:  127:}
        -:  128:
        -:  129:
        -:  130:
function ambassadorCard called 5 returned 100% blocks executed 97%
        5:  131:int ambassadorCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  132:
        -:  133:	int i;
        -:  134:	int j;
        -:  135:
        -:  136:
        5:  137:        j = 0;		//used to check if player has enough cards to discard
        -:  138:
        5:  139:        if (choice2 > 2 && choice2 < 0)  // introduced bug.  changed from || to &&
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  140:        {
    #####:  141:            return -1;
        -:  142:        }
        -:  143:
        5:  144:        if (choice1 == handPos)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  145:        {
        1:  146:            return -1;
        -:  147:        }
        -:  148:
       24:  149:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  150:        {
       20:  151:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  152:            {
        4:  153:                j++;
        -:  154:            }
        -:  155:        }
        4:  156:        if (j < choice2) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  157:        {	
        2:  158:            return -1;
        -:  159:        }
        -:  160:
        -:  161:        if (DEBUG)
        -:  162:            printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  163:
        -:  164:        //increase supply count for choosen card by amount being discarded
        2:  165:        state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  166:
        -:  167:        //each other player gains a copy of revealed card
        6:  168:        for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  169:        {
        4:  170:            if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  171:            {
        2:  172:                gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 returned 100%
        -:  173:            }
        -:  174:        }
        -:  175:
        -:  176:        //discard played card from hand
        2:  177:        discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  178:
        -:  179:        //trash copies of cards returned to supply
        3:  180:        for (j = 0; j < choice2; j++)
branch  0 taken 33%
branch  1 taken 67% (fallthrough)
        -:  181:        {
        2:  182:            for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  183:            {
        2:  184:                if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  185:                {
        1:  186:                    discardCard(i, currentPlayer, state, 0);  //intro bug.  changed to discard instead of trash, from 1 to 0
call    0 returned 100%
        1:  187:                    break;
        -:  188:                }
        -:  189:            }
        -:  190:        }
        -:  191:
        2:  192:        return 0;
        -:  193:
        -:  194:}
        -:  195:
        -:  196:
        -:  197:
function tributeCard called 8 returned 100% blocks executed 97%
        8:  198:int tributeCard (struct gameState *state, int currentPlayer) {
        -:  199:
        -:  200:	int i;
        8:  201:    	int nextPlayer = currentPlayer + 1;
        8:  202:    	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  203:        	nextPlayer = 0;
        -:  204:    	}
        -:  205:
        8:  206:    	int tributeRevealedCards[2] = {-1, -1};
        -:  207:
        8:  208:        if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        3:  209:            if (state->deckCount[nextPlayer] > 0) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  210:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        1:  211:                state->deckCount[nextPlayer]--;
        -:  212:            }
        2:  213:            else if (state->discardCount[nextPlayer] > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  214:                tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
        1:  215:                state->discardCount[nextPlayer]--;
        -:  216:            }
        -:  217:            else {
        -:  218:                //No Card to Reveal
        -:  219:                if (DEBUG) {
        -:  220:                    printf("No cards to reveal\n");
        -:  221:                }
        -:  222:            }
        -:  223:        }
        -:  224:
        -:  225:        else {
        5:  226:            if (state->deckCount[nextPlayer] == 0) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        3:  227:                for (i = 0; i <= state->discardCount[nextPlayer]; i++) {  // intro bug.  changed from < to <=
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  228:                    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        2:  229:                    state->deckCount[nextPlayer]++;
        2:  230:                    state->discard[nextPlayer][i] = -1;
        2:  231:                    state->discardCount[nextPlayer]--;
        -:  232:                }
        -:  233:
        1:  234:                shuffle(nextPlayer,state);//Shuffle the deck
call    0 returned 100%
        -:  235:            }
        5:  236:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        5:  237:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;  // -- is a bug
        5:  238:            state->deckCount[nextPlayer]--;
        5:  239:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        5:  240:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;  // -- is a bug
        5:  241:            state->deckCount[nextPlayer]--;
        -:  242:
        -:  243:            //printf("reveal0:  %d\n", tributeRevealedCards[0]);
        -:  244:            //printf("reveal1:  %d\n", tributeRevealedCards[1]);
        -:  245:        }
        -:  246:
        8:  247:        if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        3:  248:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        3:  249:            state->playedCardCount++;
        3:  250:            tributeRevealedCards[1] = -1;
        -:  251:        }
        -:  252:
       32:  253:        for (i = 0; i <= 2; i ++) {  //this is a bug, should only be <
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       24:  254:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 17% (fallthrough)
branch  5 taken 83%
        5:  255:                state->coins += 2;
        -:  256:            }
        -:  257:
       19:  258:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
branch  2 taken 90% (fallthrough)
branch  3 taken 10%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
       10:  259:                drawCard(currentPlayer, state);
call    0 returned 100%
       10:  260:                drawCard(currentPlayer, state);
call    0 returned 100%
        -:  261:            }
        -:  262:            else { //Action Card
        9:  263:                state->numActions = state->numActions - 2;  //intro bug. changed from +2 to -2.
        -:  264:            }
        -:  265:        }
        -:  266:
        -:  267:        
        8:  268:        return 0;
        -:  269:
        -:  270:
        -:  271:}
        -:  272:
        -:  273:
        -:  274:
function mineCard called 6 returned 100% blocks executed 95%
        6:  275:int mineCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  276:
        -:  277:	int i;
        -:  278:	int j;
        -:  279:
        6:  280:        j = state->hand[currentPlayer][choice2];  //store card we will trash   // intro bug. trash wrong card.  change choice1 to choice2
        -:  281:
        6:  282:        if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  283:        {
        1:  284:            return -1;
        -:  285:        }
        -:  286:
        5:  287:        if (choice2 > treasure_map || choice2 < curse) // intro bug.  changed to  choice2 < treasure_map || choice2 > curse  // but changed back 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  288:        {
    #####:  289:            return -1;
        -:  290:        }
        -:  291:
        5:  292:        if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 returned 100%
call    1 returned 100%
branch  2 taken 40% (fallthrough)
branch  3 taken 60%
        -:  293:        {
        2:  294:            return -1;
        -:  295:        }
        -:  296:
        3:  297:        gainCard(choice2, state, 2, currentPlayer);
call    0 returned 100%
        -:  298:
        -:  299:        //discard card from hand
        3:  300:        discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  301:
        -:  302:        //discard trashed card
       18:  303:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
        -:  304:        {
       16:  305:            if (state->hand[currentPlayer][i] == j)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  306:            {
        1:  307:                discardCard(i, currentPlayer, state, 0);
call    0 returned 100%
        1:  308:                break;
        -:  309:            }
        -:  310:        }
        -:  311:
        3:  312:        return 0;
        -:  313:
        -:  314:}
        -:  315:
