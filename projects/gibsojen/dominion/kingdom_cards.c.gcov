        -:    0:Source:kingdom_cards.c
        -:    0:Graph:kingdom_cards.gcno
        -:    0:Data:kingdom_cards.gcda
        -:    0:Runs:9
        -:    0:Programs:9
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4://#include <math.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:
        -:    8:
        -:    9:
        -:   10:// remove an estate from the supply
        -:   11:// this is a helper function
       12:   12:int remEstateSupply (struct gameState *state) {
       12:   13:	state->supplyCount[estate]--;//Decrement Estates
       12:   14:        if (supplyCount(estate, state) == 0) {
    #####:   15:        	isGameOver(state);
        -:   16:        }
       12:   17:	return 0;
        -:   18:}
        -:   19:
        -:   20:
        -:   21:
        -:   22:// for testing only
        -:   23:/*
        -:   24:int smithyCard (int card, int choice1, struct gameState *state, int handPos, int *bonus,
        -:   25:     	       int currentPlayer) {
        -:   26:	int i;
        -:   27:        //+3 Cards
        -:   28:        for (i = 0; i < 3; i++)
        -:   29:        {
        -:   30:            drawCard(currentPlayer, state);
        -:   31:        }
        -:   32:
        -:   33:        //discard card from hand
        -:   34:        discardCard(handPos, currentPlayer, state, 0);
        -:   35:        return 0;
        -:   36:}
        -:   37:*/
        -:   38:
       30:   39:int baronCard (int choice1, struct gameState *state, int currentPlayer) {
        -:   40:
       30:   41:	state->numBuys++;//Increase buys by 1!
       30:   42:        if (choice1 >= 0) { //Boolean true or going to discard an estate  //introduced bug from > to >=
       21:   43:            int p = 0;//Iterator for hand!
       21:   44:            int card_not_discarded = 1;//Flag for discard set!
       81:   45:            while(card_not_discarded) {
       39:   46:                if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
       18:   47:                    state->coins += 4;//Add 4 coins to the amount of coins
       18:   48:                    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        -:   49:                    //state->discardCount[currentPlayer]++;  introduced bug by removing this line
      108:   50:                    for (; p < state->handCount[currentPlayer]; p++) {
       90:   51:                        state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   52:                    }
       18:   53:                    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       18:   54:                    state->handCount[currentPlayer]--;
       18:   55:                    card_not_discarded = 0;//Exit the loop
        -:   56:                }
       21:   57:                else if (p > state->handCount[currentPlayer]) {
        -:   58:                    if(DEBUG) {
        -:   59:                        printf("No estate cards in your hand, invalid choice\n");
        -:   60:                        printf("Must gain an estate if there are any\n");
        -:   61:                    }
        3:   62:                    if (supplyCount(estate, state) > 0) {
        3:   63:                        gainCard(estate, state, 0, currentPlayer);
        -:   64:
        3:   65:			remEstateSupply(state);
        -:   66:                    }
        3:   67:                    card_not_discarded = 0;//Exit the loop
        -:   68:                }
        -:   69:
        -:   70:                else {
       18:   71:                    p++;//Next card
        -:   72:                }
        -:   73:            }
        -:   74:        }
        -:   75:
        -:   76:        else {
        9:   77:            if (supplyCount(estate, state) > 0) {
        9:   78:                gainCard(estate, state, 0, currentPlayer);//Gain an estate
        -:   79:
        9:   80:		remEstateSupply(state);
        -:   81:            }
        -:   82:        }
        -:   83:
       30:   84:	return 0;
        -:   85:}
        -:   86:
        -:   87:
        -:   88:
    #####:   89:int minionCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:   90:
        -:   91:	int i;
        -:   92:	int j;
        -:   93:        
        -:   94:	//+1 action
    #####:   95:        state->numActions++;
        -:   96:
        -:   97:        //discard card from hand
    #####:   98:        discardCard(handPos, currentPlayer, state, 0);
        -:   99:
    #####:  100:	if (choice1)
        -:  101:        {
    #####:  102:            state->coins = state->coins + 4;  //introduced bug...changed from 2 coins to 4
        -:  103:        }
    #####:  104:        else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  105:        {
        -:  106:            //discard hand
    #####:  107:            while(numHandCards(state) > 0)
        -:  108:            {
    #####:  109:                discardCard(handPos, currentPlayer, state, 0);
        -:  110:            }
        -:  111:
        -:  112:            //draw 4
    #####:  113:            for (i = 0; i < 4; i++)
        -:  114:            {
    #####:  115:                drawCard(currentPlayer, state);
        -:  116:            }
        -:  117:
        -:  118:            //other players discard hand and redraw if hand size > 4
    #####:  119:            for (i = 0; i <= state->numPlayers; i++)  // introduced bug from < to <=
        -:  120:            {
    #####:  121:                if (i != currentPlayer)
        -:  122:                {
    #####:  123:                    if ( state->handCount[i] > 4 )
        -:  124:                    {
        -:  125:                        //discard hand
    #####:  126:                        while( state->handCount[i] > 0 )
        -:  127:                        {
    #####:  128:                            discardCard(handPos, i, state, 0);
        -:  129:                        }
        -:  130:
        -:  131:                        //draw 4
    #####:  132:                        for (j = 0; j < 4; j++)
        -:  133:                        {
    #####:  134:                            drawCard(i, state);
        -:  135:                        }
        -:  136:                    }
        -:  137:                }
        -:  138:            }
        -:  139:
        -:  140:        }
    #####:  141:        return 0;
        -:  142:
        -:  143:
        -:  144:}
        -:  145:
        -:  146:
        -:  147:
    #####:  148:int ambassadorCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  149:
        -:  150:	int i;
        -:  151:	int j;
        -:  152:
        -:  153:
    #####:  154:        j = 0;		//used to check if player has enough cards to discard
        -:  155:
    #####:  156:        if (choice2 > 2 && choice2 < 0)  // introduced bug.  changed from || to &&
        -:  157:        {
    #####:  158:            return -1;
        -:  159:        }
        -:  160:
    #####:  161:        if (choice1 == handPos)
        -:  162:        {
    #####:  163:            return -1;
        -:  164:        }
        -:  165:
    #####:  166:        for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  167:        {
    #####:  168:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  169:            {
    #####:  170:                j++;
        -:  171:            }
        -:  172:        }
    #####:  173:        if (j < choice2) 
        -:  174:        {
    #####:  175:            return -1;
        -:  176:        }
        -:  177:
        -:  178:        if (DEBUG)
        -:  179:            printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  180:
        -:  181:        //increase supply count for choosen card by amount being discarded
    #####:  182:        state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  183:
        -:  184:        //each other player gains a copy of revealed card
    #####:  185:        for (i = 0; i < state->numPlayers; i++)
        -:  186:        {
    #####:  187:            if (i != currentPlayer)
        -:  188:            {
    #####:  189:                gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -:  190:            }
        -:  191:        }
        -:  192:
        -:  193:        //discard played card from hand
    #####:  194:        discardCard(handPos, currentPlayer, state, 0);
        -:  195:
        -:  196:        //trash copies of cards returned to supply
    #####:  197:        for (j = 0; j < choice2; j++)
        -:  198:        {
    #####:  199:            for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  200:            {
    #####:  201:                if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -:  202:                {
    #####:  203:                    discardCard(i, currentPlayer, state, 0);  //intro bug.  changed to discard instead of trash, from 1 to 0
    #####:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        }
        -:  208:
    #####:  209:        return 0;
        -:  210:
        -:  211:}
        -:  212:
        -:  213:
        -:  214:
    #####:  215:int tributeCard (struct gameState *state, int currentPlayer) {
        -:  216:
        -:  217:	int i;
    #####:  218:    	int nextPlayer = currentPlayer + 1;
    #####:  219:    	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  220:        	nextPlayer = 0;
        -:  221:    	}
        -:  222:
    #####:  223:    	int tributeRevealedCards[2] = {-1, -1};
        -:  224:
    #####:  225:        if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  226:            if (state->deckCount[nextPlayer] > 0) {
    #####:  227:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  228:                state->deckCount[nextPlayer]--;
        -:  229:            }
    #####:  230:            else if (state->discardCount[nextPlayer] > 0) {
    #####:  231:                tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  232:                state->discardCount[nextPlayer]--;
        -:  233:            }
        -:  234:            else {
        -:  235:                //No Card to Reveal
        -:  236:                if (DEBUG) {
        -:  237:                    printf("No cards to reveal\n");
        -:  238:                }
        -:  239:            }
        -:  240:        }
        -:  241:
        -:  242:        else {
    #####:  243:            if (state->deckCount[nextPlayer] == 0) {
    #####:  244:                for (i = 0; i <= state->discardCount[nextPlayer]; i++) {  // intro bug.  changed from < to <=
    #####:  245:                    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  246:                    state->deckCount[nextPlayer]++;
    #####:  247:                    state->discard[nextPlayer][i] = -1;
    #####:  248:                    state->discardCount[nextPlayer]--;
        -:  249:                }
        -:  250:
    #####:  251:                shuffle(nextPlayer,state);//Shuffle the deck
        -:  252:            }
    #####:  253:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  254:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  255:            state->deckCount[nextPlayer]--;
    #####:  256:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  257:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  258:            state->deckCount[nextPlayer]--;
        -:  259:        }
        -:  260:
    #####:  261:        if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
    #####:  262:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  263:            state->playedCardCount++;
    #####:  264:            tributeRevealedCards[1] = -1;
        -:  265:        }
        -:  266:
    #####:  267:        for (i = 0; i <= 2; i ++) {
    #####:  268:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
    #####:  269:                state->coins += 2;
        -:  270:            }
        -:  271:
    #####:  272:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
    #####:  273:                drawCard(currentPlayer, state);
    #####:  274:                drawCard(currentPlayer, state);
        -:  275:            }
        -:  276:            else { //Action Card
    #####:  277:                state->numActions = state->numActions - 2;  //intro bug. changed from +2 to -2.
        -:  278:            }
        -:  279:        }
        -:  280:
    #####:  281:        return 0;
        -:  282:
        -:  283:
        -:  284:}
        -:  285:
        -:  286:
        -:  287:
    #####:  288:int mineCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  289:
        -:  290:	int i;
        -:  291:	int j;
        -:  292:
    #####:  293:        j = state->hand[currentPlayer][choice2];  //store card we will trash   // intro bug. trash wrong card.  change choice1 to choice2
        -:  294:
    #####:  295:        if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  296:        {
    #####:  297:            return -1;
        -:  298:        }
        -:  299:
    #####:  300:        if (choice2 < treasure_map || choice2 > curse) // intro bug.  changed from choice2 > treasure_map || choice2 < curse to what's shown
        -:  301:        {
    #####:  302:            return -1;
        -:  303:        }
        -:  304:
    #####:  305:        if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  306:        {
    #####:  307:            return -1;
        -:  308:        }
        -:  309:
    #####:  310:        gainCard(choice2, state, 2, currentPlayer);
        -:  311:
        -:  312:        //discard card from hand
    #####:  313:        discardCard(handPos, currentPlayer, state, 0);
        -:  314:
        -:  315:        //discard trashed card
    #####:  316:        for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  317:        {
    #####:  318:            if (state->hand[currentPlayer][i] == j)
        -:  319:            {
    #####:  320:                discardCard(i, currentPlayer, state, 0);
    #####:  321:                break;
        -:  322:            }
        -:  323:        }
        -:  324:
    #####:  325:        return 0;
        -:  326:
        -:  327:}
        -:  328:
