        -:    0:Source:kingdom_cards.c
        -:    0:Graph:kingdom_cards.gcno
        -:    0:Data:kingdom_cards.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4://#include <math.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:
        -:    8:
        -:    9:
        -:   10:// remove an estate from the supply
        -:   11:// this is a helper function
function remEstateSupply called 277 returned 100% blocks executed 80%
      277:   12:int remEstateSupply (struct gameState *state) {
      277:   13:	state->supplyCount[estate]--;//Decrement Estates
      277:   14:        if (supplyCount(estate, state) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   15:        	isGameOver(state);
call    0 never executed
        -:   16:        }
      277:   17:	return 0;
        -:   18:}
        -:   19:
        -:   20:
        -:   21:
        -:   22:// for testing only
        -:   23:/*
        -:   24:int smithyCard (int card, int choice1, struct gameState *state, int handPos, int *bonus,
        -:   25:     	       int currentPlayer) {
        -:   26:	int i;
        -:   27:        //+3 Cards
        -:   28:        for (i = 0; i < 3; i++)
        -:   29:        {
        -:   30:            drawCard(currentPlayer, state);
        -:   31:        }
        -:   32:
        -:   33:        //discard card from hand
        -:   34:        discardCard(handPos, currentPlayer, state, 0);
        -:   35:        return 0;
        -:   36:}
        -:   37:*/
        -:   38:
function baronCard called 2000 returned 100% blocks executed 100%
     2000:   39:int baronCard (int choice1, struct gameState *state, int currentPlayer) {
        -:   40:
     2000:   41:	state->numBuys++;//Increase buys by 1!
     2000:   42:        if (choice1 >= 0) { //Boolean true or going to discard an estate  //introduced bug from > to >=
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
     1489:   43:            int p = 0;//Iterator for hand!
     1489:   44:            int card_not_discarded = 1;//Flag for discard set!
    17645:   45:            while(card_not_discarded) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    14667:   46:                if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
     1455:   47:                    state->coins += 4;//Add 4 coins to the amount of coins
     1455:   48:                    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        -:   49:                    //state->discardCount[currentPlayer]++;  introduced bug by removing this line
   370429:   50:                    for (; p < state->handCount[currentPlayer]; p++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   368974:   51:                        state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   52:                    }
     1455:   53:                    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
     1455:   54:                    state->handCount[currentPlayer]--;
     1455:   55:                    card_not_discarded = 0;//Exit the loop
        -:   56:                }
    13212:   57:                else if (p > state->handCount[currentPlayer]) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   58:                    if(DEBUG) {
        -:   59:                        printf("No estate cards in your hand, invalid choice\n");
        -:   60:                        printf("Must gain an estate if there are any\n");
        -:   61:                    }
       34:   62:                    if (supplyCount(estate, state) > 0) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
       17:   63:                        gainCard(estate, state, 0, currentPlayer);
call    0 returned 100%
        -:   64:
       17:   65:			remEstateSupply(state);
call    0 returned 100%
        -:   66:                    }
       34:   67:                    card_not_discarded = 0;//Exit the loop
        -:   68:                }
        -:   69:
        -:   70:                else {
    13178:   71:                    p++;//Next card
        -:   72:                }
        -:   73:            }
        -:   74:        }
        -:   75:
        -:   76:        else {
      511:   77:            if (supplyCount(estate, state) > 0) {
call    0 returned 100%
branch  1 taken 51% (fallthrough)
branch  2 taken 49%
      260:   78:                gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 100%
        -:   79:
      260:   80:		remEstateSupply(state);
call    0 returned 100%
        -:   81:            }
        -:   82:        }
        -:   83:
     2000:   84:	return 0;
        -:   85:}
        -:   86:
        -:   87:
        -:   88:
function minionCard called 2000 returned 100% blocks executed 100%
     2000:   89:int minionCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:   90:
        -:   91:	int i;
        -:   92:	int j;
        -:   93:        
        -:   94:	//+1 action
     2000:   95:        state->numActions++;
        -:   96:
        -:   97:        //discard card from hand
     2000:   98:        discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:   99:
     2000:  100:	if (choice1)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  101:        {
     1509:  102:            state->coins = state->coins + 4;  //introduced bug...changed from 2 coins to 4
        -:  103:        }
      491:  104:        else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
        -:  105:        {
        -:  106:            //discard hand
    91699:  107:            while(numHandCards(state) > 0)
call    0 returned 100%
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
        -:  108:            {
    90993:  109:                discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  110:            }
        -:  111:
        -:  112:            //draw 4
     1765:  113:            for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  114:           {  
     1412:  115:                drawCard(currentPlayer, state);
call    0 returned 100%
        -:  116:            }
        -:  117:
        -:  118:            //other players discard hand and redraw if hand size > 4
     1059:  119:            for (i = 0; i < state->numPlayers; i++)  // introduced bug from < to <= //fixed for random tests, caused seg fault
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  120:            {
      706:  121:                if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  122:                {
        -:  123:                //printf("i:  %d\n", i);
        -:  124:	        //printf("state->handCount[i] = %d\n", state->handCount[i]);
      353:  125:                    if ( state->handCount[i] > 4 )
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  126:                    {
        -:  127:                        //discard hand
    92031:  128:                        while( state->handCount[i] > 0 )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  129:                        {
    91335:  130:                            discardCard(handPos, i, state, 0);
call    0 returned 100%
        -:  131:                        }
        -:  132:
        -:  133:                        //draw 4
     1740:  134:                        for (j = 0; j < 4; j++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  135:                        {
     1392:  136:                            drawCard(i, state);
call    0 returned 100%
        -:  137:                        }
        -:  138:                    }
        -:  139:                }
        -:  140:            }
        -:  141:
        -:  142:        }
        -:  143:
        -:  144: 
     2000:  145:        return 0;
        -:  146:
        -:  147:
        -:  148:}
        -:  149:
        -:  150:
        -:  151:
function ambassadorCard called 0 returned 0% blocks executed 0%
    #####:  152:int ambassadorCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  153:
        -:  154:	int i;
        -:  155:	int j;
        -:  156:
        -:  157:
    #####:  158:        j = 0;		//used to check if player has enough cards to discard
        -:  159:
    #####:  160:        if (choice2 > 2 && choice2 < 0)  // introduced bug.  changed from || to &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  161:        {
    #####:  162:            return -1;
        -:  163:        }
        -:  164:
    #####:  165:        if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  166:        {
    #####:  167:            return -1;
        -:  168:        }
        -:  169:
    #####:  170:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  171:        {
    #####:  172:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  173:            {
    #####:  174:                j++;
        -:  175:            }
        -:  176:        }
    #####:  177:        if (j < choice2) 
branch  0 never executed
branch  1 never executed
        -:  178:        {
    #####:  179:            return -1;
        -:  180:        }
        -:  181:
        -:  182:        if (DEBUG)
        -:  183:            printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  184:
        -:  185:        //increase supply count for choosen card by amount being discarded
    #####:  186:        state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  187:
        -:  188:        //each other player gains a copy of revealed card
    #####:  189:        for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  190:        {
    #####:  191:            if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  192:            {
    #####:  193:                gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  194:            }
        -:  195:        }
        -:  196:
        -:  197:        //discard played card from hand
    #####:  198:        discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  199:
        -:  200:        //trash copies of cards returned to supply
    #####:  201:        for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -:  202:        {
    #####:  203:            for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  204:            {
    #####:  205:                if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -:  206:                {
    #####:  207:                    discardCard(i, currentPlayer, state, 0);  //intro bug.  changed to discard instead of trash, from 1 to 0
call    0 never executed
    #####:  208:                    break;
        -:  209:                }
        -:  210:            }
        -:  211:        }
        -:  212:
    #####:  213:        return 0;
        -:  214:
        -:  215:}
        -:  216:
        -:  217:
        -:  218:
function tributeCard called 2000 returned 100% blocks executed 88%
     2000:  219:int tributeCard (struct gameState *state, int currentPlayer) {
        -:  220:
        -:  221:	int i;
     2000:  222:    	int nextPlayer = currentPlayer + 1;
     2000:  223:    	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
     1018:  224:        	nextPlayer = 0;
        -:  225:    	}
        -:  226:
     2000:  227:    	int tributeRevealedCards[2] = {-1, -1};
        -:  228:
     2000:  229:        if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  230:            if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####:  231:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  232:                state->deckCount[nextPlayer]--;
        -:  233:            }
    #####:  234:            else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####:  235:                tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  236:                state->discardCount[nextPlayer]--;
        -:  237:            }
        -:  238:            else {
        -:  239:                //No Card to Reveal
        -:  240:                if (DEBUG) {
        -:  241:                    printf("No cards to reveal\n");
        -:  242:                }
        -:  243:            }
        -:  244:        }
        -:  245:
        -:  246:        else {
     2000:  247:            if (state->deckCount[nextPlayer] == 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      899:  248:                for (i = 0; i <= state->discardCount[nextPlayer]; i++) {  // intro bug.  changed from < to <= 
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      893:  249:                    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
      893:  250:                    state->deckCount[nextPlayer]++;
      893:  251:                    state->discard[nextPlayer][i] = -1;
      893:  252:                    state->discardCount[nextPlayer]--;
        -:  253:                }
        -:  254:
        6:  255:                shuffle(nextPlayer,state);//Shuffle the deck
call    0 returned 100%
        -:  256:            }
     2000:  257:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     2000:  258:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     2000:  259:            state->deckCount[nextPlayer]--;
     2000:  260:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     2000:  261:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     2000:  262:            state->deckCount[nextPlayer]--;
        -:  263:        }
        -:  264:
     2000:  265:        if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
branch  0 taken 11% (fallthrough)
branch  1 taken 90%
      210:  266:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
      210:  267:            state->playedCardCount++;
      210:  268:            tributeRevealedCards[1] = -1;
        -:  269:        }
        -:  270:
     8000:  271:        for (i = 0; i <= 2; i ++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     6000:  272:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
branch  2 taken 93% (fallthrough)
branch  3 taken 7%
branch  4 taken 8% (fallthrough)
branch  5 taken 92%
     1133:  273:                state->coins += 2;
        -:  274:            }
        -:  275:
     4867:  276:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 89% (fallthrough)
branch  5 taken 11%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
     1746:  277:                drawCard(currentPlayer, state);
call    0 returned 100%
     1746:  278:                drawCard(currentPlayer, state);
call    0 returned 100%
        -:  279:            }
        -:  280:            else { //Action Card
     3121:  281:                state->numActions = state->numActions - 2;  //intro bug. changed from +2 to -2.
        -:  282:            }
        -:  283:        }
        -:  284:
     2000:  285:        return 0;
        -:  286:
        -:  287:
        -:  288:}
        -:  289:
        -:  290:
        -:  291:
function mineCard called 0 returned 0% blocks executed 0%
    #####:  292:int mineCard (int choice1, int choice2, struct gameState *state, int handPos, int currentPlayer) {
        -:  293:
        -:  294:	int i;
        -:  295:	int j;
        -:  296:
    #####:  297:        j = state->hand[currentPlayer][choice2];  //store card we will trash   // intro bug. trash wrong card.  change choice1 to choice2
        -:  298:
    #####:  299:        if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  300:        {
    #####:  301:            return -1;
        -:  302:        }
        -:  303:
    #####:  304:        if (choice2 < treasure_map || choice2 > curse) // intro bug.  changed from choice2 > treasure_map || choice2 < curse to what's shown
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  305:        {
    #####:  306:            return -1;
        -:  307:        }
        -:  308:
    #####:  309:        if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  310:        {
    #####:  311:            return -1;
        -:  312:        }
        -:  313:
    #####:  314:        gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  315:
        -:  316:        //discard card from hand
    #####:  317:        discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  318:
        -:  319:        //discard trashed card
    #####:  320:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  321:        {
    #####:  322:            if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  323:            {
    #####:  324:                discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  325:                break;
        -:  326:            }
        -:  327:        }
        -:  328:
    #####:  329:        return 0;
        -:  330:
        -:  331:}
        -:  332:
